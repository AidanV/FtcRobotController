Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/ftc10650/Tele/OdometryTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.ftc10650.Tele;\n\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\nimport com.qualcomm.robotcore.hardware.DcMotor;\n\nimport org.firstinspires.ftc.teamcode.Calculators.*;\nimport org.firstinspires.ftc.teamcode.Op.ComplexOp;\nimport org.firstinspires.ftc.teamcode.Utilities.Vector2D;\nimport org.firstinspires.ftc.teamcode.Utilities.Vector3D;\n\nimport java.util.Vector;\n\n@TeleOp(name = \"Odom Test\", group = \"ftc10650\")\npublic class OdometryTest extends ComplexOp {\n\n    Vector<SpeedCalcs.ProgressSpeed> s = new Vector<SpeedCalcs.ProgressSpeed>();\n    Vector<Vector3D> p = new Vector<Vector3D>();\n\n    @Override\n    public Interfaces.MoveData.StartData startPositionAndOrientation() {\n        return new Interfaces.MoveData.StartData(new Vector2D(50, 50), 90);\n    }\n\n    @Override\n    public void initMove() throws InterruptedException {\n\n//        s.add(new SpeedCalcs.ProgressSpeed(0.05, 0, SpeedCalcs.ProgressSpeed.timeOrProg.PROG));\n//        s.add(new SpeedCalcs.ProgressSpeed(0.2, 1, SpeedCalcs.ProgressSpeed.timeOrProg.PROG));\n//        p.add(new Vector3D(0, 0.3f, 0.3f));\n        d.robot.barm.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        d.robot.tarm.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n        while(d.robot.bop.getState()) {\n            d.robot.barm.setPower(-0.2);\n            d.robot.tarm.setPower(-0.08);\n        }\n        d.robot.barm.setPower(0.0);\n        d.robot.barm.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        d.robot.barm.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        d.initBarmPos = d.robot.barm.getCurrentPosition();\n//        d.robot.barm.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n        while(d.robot.top.getState()) {\n            d.robot.tarm.setPower(0.2);\n        }\n        d.robot.tarm.setPower(0.0);\n        d.robot.tarm.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        d.robot.tarm.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        d.initTarmPos = d.robot.tarm.getCurrentPosition();\n        d.initSarmPos = d.robot.sarm.getCurrentPosition();\n//        d.robot.tarm.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n\n    }\n\n    @Override\n    public void body() throws InterruptedException {\n\n        ComplexMove(\n//                null,\n//null,\n//null,\n//                SpeedCalcs.SetSpeed(1.0),\n               SpeedCalcs.JoystickSpeed(),\n//                MotionCalcs.ObjectCentricJoystick(),\n                MotionCalcs.FieldCentricJoystick(0),\n                //MotionCalcs.ConstantDistanceToPoint(100, new Vector2D(100,100)),\n                OrientationCalcs.turnWithJoystick(),\n//                OrientationCalcs.lookToOrientationUnderJoystick(0),\n//                OrientationCalcs.lookToGoal(),\n//                OrientationCalcs.lookToPower(),\n//                OtherCalcs.Arm(),\n//                OtherCalcs.ArmPath(s, p),\n\n                OtherCalcs.Arm2D(),\n                OtherCalcs.Claw(),\n                OtherCalcs.Duck(),\n                OtherCalcs.TelemetryPosition());\n                /*OrientationCalcs.lookToPointTurnWithBumperTurnWithJoystick(\n                        \"a\",\n                        new OrientationCalcs.lookProgress(new Vector2D(0,0),0.95),\n                        new OrientationCalcs.lookProgress(new Vector2D(150,150),1.0)),*/\n        /**\n         * OtherCalcs.armPath(speeds... , points...\n         */\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/ftc10650/Tele/OdometryTest.java	(revision 41983f78e90897951c2ad4db0f0ea7dce802dc80)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/ftc10650/Tele/OdometryTest.java	(date 1638221603000)
@@ -70,7 +70,8 @@
 //                OtherCalcs.ArmPath(s, p),
 
                 OtherCalcs.Arm2D(),
-                OtherCalcs.Claw(),
+//                OtherCalcs.Claw(),
+                OtherCalcs.ClawCubeGrab(),
                 OtherCalcs.Duck(),
                 OtherCalcs.TelemetryPosition());
                 /*OrientationCalcs.lookToPointTurnWithBumperTurnWithJoystick(
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Hardware/Sensors/CubeFindPipeline.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.Hardware.Sensors;\n\nimport org.opencv.core.*;\nimport org.opencv.imgproc.Imgproc;\nimport org.openftc.easyopencv.OpenCvPipeline;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class CubeFindPipeline extends OpenCvPipeline {\n    Mat grey = new Mat();\n    Mat hsv = new Mat();\n    Mat mask = new Mat();\n    Mat hierarchy = new Mat();\n\n    @Override\n    public Mat processFrame(Mat input) {\n//        final Scalar lower = new Scalar(0, 0, 20);//188.1, 148.92);\n//        final Scalar upper = new Scalar(50, 255, 250);//203.7, 255);\n        final Scalar lower = new Scalar(11, 50, 20);//150, 90\n        final Scalar upper = new Scalar(18, 255, 250);// 230, 255\n\n\n        Imgproc.cvtColor(input, hsv, Imgproc.COLOR_RGB2HSV);\n\n        Core.inRange(hsv, lower, upper, mask);\n\n\n        grey.empty();\n        Core.add(grey, new Scalar(255, 0, 0), grey);\n//        input.copyTo(grey, mask);\n//        Mat kernel = Imgproc.getStructuringElement(Imgproc.MORPH_RECT, new Size((1) + 1, (1)+1));\n//        Imgproc.erode(mask, mask, kernel);\n//        Imgproc.dilate(mask, mask, kernel);\n//\n//        List<MatOfPoint> contours = new ArrayList<>();\n//        Imgproc.findContours(mask, contours, hierarchy, Imgproc.RETR_TREE, Imgproc.CHAIN_APPROX_SIMPLE);\n//        double maxArea = 0;\n//        MatOfPoint largestContour = new MatOfPoint();\n//        for (MatOfPoint contour : contours) {\n//            double area = Imgproc.contourArea(contour);\n//            if (area > maxArea) {\n//                maxArea = area;\n//                largestContour = contour;\n//            }\n//        }\n//        Rect boundingRect = Imgproc.boundingRect(largestContour);\n//        Imgproc.rectangle(mask, boundingRect, new Scalar(255, 0, 0), 3);\n\n\n//        Imgproc.cvtColor(mask, mask, Imgproc.COLOR_GRAY2RGB);\n//        Core.bitwise_not(input, input, mask);\n//        Core.bitwise_not(input, input, mask);\n//        Core.bitwise_and(input, mask, input);\n//162, 100, 42\n//255, 210, 137\n//149, 73, 30\n\n//HSV\n//37, 46.3%, 100%\n//22, 79.9%, 58.4%\n\n//        Imgproc.cvtColor(input, grey, Imgproc.COLOR_RGB2GRAY);\n        return grey;\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Hardware/Sensors/CubeFindPipeline.java	(revision 41983f78e90897951c2ad4db0f0ea7dce802dc80)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Hardware/Sensors/CubeFindPipeline.java	(date 1638491229000)
@@ -1,5 +1,7 @@
 package org.firstinspires.ftc.teamcode.Hardware.Sensors;
 
+import com.vuforia.Rectangle;
+
 import org.opencv.core.*;
 import org.opencv.imgproc.Imgproc;
 import org.openftc.easyopencv.OpenCvPipeline;
@@ -12,13 +14,14 @@
     Mat hsv = new Mat();
     Mat mask = new Mat();
     Mat hierarchy = new Mat();
+    Rect cube = new Rect();
 
     @Override
     public Mat processFrame(Mat input) {
 //        final Scalar lower = new Scalar(0, 0, 20);//188.1, 148.92);
 //        final Scalar upper = new Scalar(50, 255, 250);//203.7, 255);
-        final Scalar lower = new Scalar(11, 50, 20);//150, 90
-        final Scalar upper = new Scalar(18, 255, 250);// 230, 255
+        final Scalar lower = new Scalar(4, 182, 111);//150, 90
+        final Scalar upper = new Scalar(35, 255, 255);// 230, 255
 
 
         Imgproc.cvtColor(input, hsv, Imgproc.COLOR_RGB2HSV);
@@ -26,26 +29,26 @@
         Core.inRange(hsv, lower, upper, mask);
 
 
-        grey.empty();
-        Core.add(grey, new Scalar(255, 0, 0), grey);
+//        grey.empty();
+//        Core.add(grey, new Scalar(255, 0, 0), grey);
 //        input.copyTo(grey, mask);
-//        Mat kernel = Imgproc.getStructuringElement(Imgproc.MORPH_RECT, new Size((1) + 1, (1)+1));
-//        Imgproc.erode(mask, mask, kernel);
-//        Imgproc.dilate(mask, mask, kernel);
+        Mat kernel = Imgproc.getStructuringElement(Imgproc.MORPH_RECT, new Size((2) + 1, (2)+1));
+        Imgproc.erode(mask, mask, kernel);
+        Imgproc.dilate(mask, mask, kernel);
 //
-//        List<MatOfPoint> contours = new ArrayList<>();
-//        Imgproc.findContours(mask, contours, hierarchy, Imgproc.RETR_TREE, Imgproc.CHAIN_APPROX_SIMPLE);
-//        double maxArea = 0;
-//        MatOfPoint largestContour = new MatOfPoint();
-//        for (MatOfPoint contour : contours) {
-//            double area = Imgproc.contourArea(contour);
-//            if (area > maxArea) {
-//                maxArea = area;
-//                largestContour = contour;
-//            }
-//        }
-//        Rect boundingRect = Imgproc.boundingRect(largestContour);
-//        Imgproc.rectangle(mask, boundingRect, new Scalar(255, 0, 0), 3);
+        List<MatOfPoint> contours = new ArrayList<>();
+        Imgproc.findContours(mask, contours, hierarchy, Imgproc.RETR_TREE, Imgproc.CHAIN_APPROX_SIMPLE);
+        double maxArea = 0;
+        MatOfPoint largestContour = new MatOfPoint();
+        for (MatOfPoint contour : contours) {
+            double area = Imgproc.contourArea(contour);
+            if (area > maxArea) {
+                maxArea = area;
+                largestContour = contour;
+            }
+        }
+        cube = Imgproc.boundingRect(largestContour);
+        Imgproc.rectangle(input, cube, new Scalar(255, 0, 0), 3);
 
 
 //        Imgproc.cvtColor(mask, mask, Imgproc.COLOR_GRAY2RGB);
@@ -55,12 +58,23 @@
 //162, 100, 42
 //255, 210, 137
 //149, 73, 30
-
+//255, 242, 73
+//111, 20, 0
 //HSV
 //37, 46.3%, 100%
+
 //22, 79.9%, 58.4%
+//56, 71.4%, 100%
+//11, 100%, 43.5%
 
 //        Imgproc.cvtColor(input, grey, Imgproc.COLOR_RGB2GRAY);
-        return grey;
+        return input;
+    }
+
+    public double[] cubePosPercent(){
+        return new double[]{((cube.br().x + cube.tl().x) / 2.0)/1920.0, ((cube.br().y + cube.tl().y) / 2.0)/1080.0};
+    }
+    public double cubeSize(){
+        return cube.area();
     }
 }
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Calculators/OtherCalcs.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.Calculators;\n\nimport com.qualcomm.robotcore.hardware.DcMotor;\n\n//import org.firstinspires.ftc.teamcode.Hardware.Sensors.GoalPositionPipeline;\n//import org.firstinspires.ftc.teamcode.Hardware.Sensors.PowerShotPositionPipeline;\n//import org.firstinspires.ftc.teamcode.Hardware.Sensors.StackDeterminationPipeline;\nimport org.firstinspires.ftc.teamcode.Utilities.*;\n\nimport java.util.Vector;\n//import org.openftc.easyopencv.OpenCvCamera;\n//import org.openftc.easyopencv.OpenCvCameraRotation;\n\npublic class OtherCalcs {\n\n    public static Interfaces.OtherCalc whileOpMode(){\n\n        return new Interfaces.OtherCalc(){\n            double myProgress;\n            @Override\n            public double myProgress(Interfaces.MoveData d) {\n                return myProgress;\n            }\n\n            @Override\n            public void CalcOther(Interfaces.MoveData d){\n                myProgress = 0.5;\n            }\n        };\n    }\n\n    public static Interfaces.OtherCalc TimeProgress(final long millis){\n        return new Interfaces.OtherCalc() {\n            long finalMillis = millis + System.currentTimeMillis();\n            long initialMillis = System.currentTimeMillis();\n            @Override\n            public void CalcOther(Interfaces.MoveData d) {\n\n            }\n\n            @Override\n            public double myProgress(Interfaces.MoveData d) {\n                return (System.currentTimeMillis() - initialMillis)/(finalMillis - initialMillis);\n            }\n        };\n    }\n\n//    public static Interfaces.OtherCalc Bucket(){\n//\n//        return new Interfaces.OtherCalc(){\n//            double myProgress;\n//            @Override\n//            public double myProgress(Interfaces.MoveData d) {\n//                return myProgress;\n//            }\n//\n//            @Override\n//            public void CalcOther(Interfaces.MoveData d) {\n//                final double SHOOTPOSITION = 0.24;\n//                //d.robot.bucket.setPosition((d.MAXBUCKET-d.MINBUCKET)*((d.manip.ls().y+1.0)/2.0)+d.MINBUCKET);\n//                if(d.manip.rb()) d.robot.bucket.setPosition(SHOOTPOSITION);\n//                else d.robot.bucket.setPosition(0.68);\n//\n//                //else d.robot.bucket.setPosition((d.MAXBUCKET-d.MINBUCKET)*(1-d.manip.rt()) + d.MINBUCKET);\n//\n//                if(d.manip.b()) {\n//                    d.robot.pusher.setPosition(1.0);\n//                } else {\n//                    d.robot.pusher.setPosition(0.0);\n//                }\n//            }\n//        };\n//    }\n\n//    public static Interfaces.OtherCalc SetBucketPositionWithProgress(final double position){\n//\n//        return new Interfaces.OtherCalc(){\n//            boolean prog = false;\n//            @Override\n//            public double myProgress(Interfaces.MoveData d) {\n//                return prog?1:0;\n//            }\n//\n//            @Override\n//            public void CalcOther(Interfaces.MoveData d) {\n//\n//                d.robot.bucket.setPosition(position);\n//                prog = true;\n//            }\n//        };\n//    }\n\n//    public static Interfaces.OtherCalc SetBucketPosition(final double position){\n//\n//        return new Interfaces.OtherCalc(){\n//\n//            @Override\n//            public double myProgress(Interfaces.MoveData d) {\n//                return 0;\n//            }\n//\n//            @Override\n//            public void CalcOther(Interfaces.MoveData d) {\n//\n//                d.robot.bucket.setPosition(position);\n//\n//            }\n//        };\n//    }\n\n//    public static Interfaces.OtherCalc SetShooterSpeed(final double speed){\n//\n//        return new Interfaces.OtherCalc(){\n//            boolean prog = false;\n//            @Override\n//            public double myProgress(Interfaces.MoveData d) {\n//                return prog?1:0;\n//            }\n//\n//            @Override\n//            public void CalcOther(Interfaces.MoveData d) {\n//\n//                d.robot.shooterEx.setVelocity(speed);\n//            }\n//        };\n//    }\n\n//    public static Interfaces.OtherCalc Shooting(final int loop){\n//\n//        return new Interfaces.OtherCalc(){\n//            boolean prog = false;\n//            int i = 0;\n//            int l = loop;\n//            long startTime = System.currentTimeMillis();\n//\n//            @Override\n//            public void CalcOther(Interfaces.MoveData d) {\n//                //ASSUMING THAT THE BUCKET AND SHOOTER IS ALREADY IN POSITION BECAUSE OF TIME\n//                d.robot.bucket.setPosition(0.24);\n//                d.robot.shooterEx.setVelocity(1690);\n//                long thisTime = System.currentTimeMillis();\n//\n//                switch(i){\n//                    case 0:\n//                        d.robot.pusher.setPosition(1.0);\n//                        if((thisTime-startTime)>400) {\n//                            i = 1;\n//                            startTime = System.currentTimeMillis();\n//                        }\n//                        break;\n//                    case 1:\n//                        d.robot.pusher.setPosition(0.0);\n//                        if((thisTime-startTime)>600) {\n//                            i = 0;\n//                            startTime = System.currentTimeMillis();\n//                            l--;\n//                        }\n//\n//                        break;\n//                }\n//                if(l<=0) {\n//                    prog = true;\n//                }\n//            }\n//\n//            @Override\n//            public double myProgress(Interfaces.MoveData d) {\n//                return prog?1:0;\n//            }\n//        };\n//    }\n//\n//    public static Interfaces.OtherCalc Shoot(){\n//        return new Interfaces.OtherCalc() {\n//            //double myProg = 0.0;\n//            boolean prog = false;\n//            TimeUtil time = new TimeUtil();\n//            @Override\n//            public void CalcOther(Interfaces.MoveData d) {\n//                if(!prog) {\n//                    d.robot.shooterEx.setVelocity(1842.0);//1820//1850\n//                    d.robot.bucket.setPosition(0.24);\n//                    time.startTimer(1000);\n//                    while (!time.timerDone()) ;\n//                    //d.robot.shooter.setPower(0.547);\n//                    time.resetTimer();\n//                    time.startTimer(1000);\n//                    while (!time.timerDone()) ;\n//                    time.resetTimer();\n//                    time.startTimer(1000);\n//                    while (!time.timerDone()) {\n//                        d.robot.pusher.setPosition(1.0);\n//                    }\n////                    time.resetTimer();\n////                    time.startTimer(1000);\n////                    while (!time.timerDone()) {\n////                        d.robot.pusher.setPosition(0.0);\n////                        d.robot.bucket.setPosition(0.40);\n////                    }\n////                    time.resetTimer();\n////                    time.startTimer(1000);\n////                    while(!time.timerDone()){\n////                        d.robot.bucket.setPosition(0.24);\n////                    }\n////                    time.resetTimer();\n////                    time.startTimer(1000);\n////                    while (!time.timerDone()) {\n////                        d.robot.pusher.setPosition(1.0);\n////                    }\n////\n////                    time.resetTimer();\n////                    time.startTimer(1000);\n////                    while (!time.timerDone()) {\n////                        d.robot.pusher.setPosition(0.0);\n////                        d.robot.bucket.setPosition(0.40);\n////                    }\n////                    time.resetTimer();\n////                    time.startTimer(1000);\n////                    while(!time.timerDone()){\n////                        d.robot.bucket.setPosition(0.24);\n////                    }\n////\n////                    time.resetTimer();\n////                    time.startTimer(1000);\n////                    while (!time.timerDone()) {\n////                        d.robot.pusher.setPosition(1.0);\n////                    }\n////                    time.resetTimer();\n////                    time.startTimer(1000);\n////                    while (!time.timerDone()) {\n////                        d.robot.pusher.setPosition(0.0);\n////                        d.robot.bucket.setPosition(0.40);\n////                    }\n////                    time.resetTimer();\n////                    time.startTimer(1000);\n////                    while(!time.timerDone()){\n////                        d.robot.bucket.setPosition(0.24);\n////                    }\n////                    time.resetTimer();\n////                    time.startTimer(1000);\n////                    while (!time.timerDone()) {\n////                        d.robot.pusher.setPosition(1.0);\n////                    }\n////                    time.resetTimer();\n////                    time.startTimer(1000);\n////                    while (!time.timerDone()) {\n////                        d.robot.pusher.setPosition(0.0);\n////                        d.robot.bucket.setPosition(0.40);\n////                    }\n////                    time.resetTimer();\n////                    time.startTimer(1000);\n////                    while(!time.timerDone()){\n////                        d.robot.bucket.setPosition(0.24);\n////                    }\n////                    time.resetTimer();\n////                    time.startTimer(1000);\n////                    while (!time.timerDone()) {\n////                        d.robot.pusher.setPosition(1.0);\n////                    }\n////                    time.resetTimer();\n////                    time.startTimer(1000);\n////                    while (!time.timerDone()) {\n////                        d.robot.pusher.setPosition(0.0);\n////                        d.robot.bucket.setPosition(0.40);\n////                    }\n////                    time.resetTimer();\n////                    time.startTimer(1000);\n////                    while(!time.timerDone()){\n////                        d.robot.bucket.setPosition(0.24);\n////                    }\n////                    d.robot.shooter.setPower(0.0);\n//                    d.robot.shooterEx.setVelocity(0.0);\n//                    d.robot.pusher.setPosition(0.0);\n//                    d.robot.bucket.setPosition(0.68);\n//                    prog = true;\n//                }\n//            }\n//\n//            @Override\n//            public double myProgress(Interfaces.MoveData d) {\n//                if(prog)return 1.0;\n//                return 0.0;\n//            }\n//        };\n//    }\n//    public static Interfaces.OtherCalc Intake(){\n//        return new Interfaces.OtherCalc() {\n//            @Override\n//            public void CalcOther(Interfaces.MoveData d) {\n//                if(d.manip.a()) d.robot.intakeEx.setVelocity(1000);\n//                else if(d.manip.y()) d.robot.intakeEx.setVelocity(-1600);\n//                else d.robot.intake.setPower(0.0);\n//\n//            }\n//\n//            @Override\n//            public double myProgress(Interfaces.MoveData d) {\n//                return 0;\n//            }\n//        };\n//    }\n//\n//    public static Interfaces.OtherCalc Intake(final double speed){\n//        return new Interfaces.OtherCalc() {\n//            int i = 0;\n//            @Override\n//            public void CalcOther(Interfaces.MoveData d) {\n//                d.robot.intakeEx.setVelocity(speed);\n//                i=1;\n//            }\n//\n//            @Override\n//            public double myProgress(Interfaces.MoveData d) {\n//                return i;\n//            }\n//        };\n//    }\n//\n//    public static Interfaces.OtherCalc Intake(final boolean on){\n//        return new Interfaces.OtherCalc() {\n//            @Override\n//            public void CalcOther(Interfaces.MoveData d) {\n//                d.robot.intakeEx.setVelocity(on?1000:0);\n//            }\n//\n//            @Override\n//            public double myProgress(Interfaces.MoveData d) {\n//                return 0;\n//            }\n//        };\n//    }\n\n    public static Interfaces.OtherCalc PIDTest(){\n        return new Interfaces.OtherCalc() {\n            @Override\n            public void CalcOther(Interfaces.MoveData d) {\n                if(d.manip.u()){\n\n                }\n            }\n\n            @Override\n            public double myProgress(Interfaces.MoveData d) {\n                return 0;\n            }\n        };\n    }\n\n//    public static Interfaces.OtherCalc Lift(){\n//        return new Interfaces.OtherCalc() {\n//            @Override\n//            public void CalcOther(Interfaces.MoveData d) {\n//                d.robot.vex.setPower(d.manip.ls().y);\n//            }\n//\n//            @Override\n//            public double myProgress(Interfaces.MoveData d) {\n//                return 0;\n//            }\n//        };\n//    }\n//\n//    // Method to yeet\n//    //Very cool aidan\n//    //wow\n//    //i like this one\n//    public static Interfaces.OtherCalc Yeetor(){\n//        return new Interfaces.OtherCalc() {\n//            @Override\n//            public void CalcOther(Interfaces.MoveData d) {\n//\n////                if(d.manip.lb()) d.robot.shooter.setPower(1.0);\n////                else d.robot.shooter.setPower(d.manip.lt());\n//                double newVelocity;\n//                if(d.manip.ls().y>0.5) newVelocity = 1740.0;\n//                else if (d.manip.ls().y<-0.5) newVelocity = 1500;\n//                else newVelocity = 2200*d.manip.lt();\n//                d.robot.shooterEx.setVelocity(newVelocity);\n//                d.shooterCommand = newVelocity;\n//            }\n//\n//\n//            @Override\n//            public double myProgress(Interfaces.MoveData d) {\n//                return 0;\n//            }\n//        };\n//    }\n//\n//    public static Interfaces.OtherCalc Wobble(){\n//        return new Interfaces.OtherCalc() {\n//            boolean dx = true;\n//            boolean grab = false;\n//            short i = 0;\n//            @Override\n//            public void CalcOther(Interfaces.MoveData d) {\n//                if(dx&&d.manip.x()){\n//                    dx=false;\n//                    i++;\n//                }\n//                if(!d.manip.x()) dx = true;\n//                if(i == 0){\n//                    d.robot.wobble.setTargetPosition(3+d.robot.wobbleOffset);\n//                } else if (i == 1) {\n//                    d.robot.wobble.setTargetPosition(585+d.robot.wobbleOffset);//575//550//520//170\n//                } //else if (i == 2){\n////                    d.robot.wobble.setTargetPosition(0);\n////                } else {\n////                    d.robot.wobble.setTargetPosition(70);\n////                }\n//                i%=2;\n//                if(d.manip.l()) grab = true;\n//                if(d.manip.r()) grab = false;\n//                if(grab) d.robot.graber.setPosition(0.8);\n//                else d.robot.graber.setPosition(0);\n//                //                d.robot.wobble.setPower(d.manip.rs().x/20);\n//            }\n//\n//            @Override\n//            public double myProgress(Interfaces.MoveData d) {\n//                return 0;\n//            }\n//        };\n//    }\n//\n//    public static Interfaces.OtherCalc SetGrabberPosition(final boolean grab){\n//        return new Interfaces.OtherCalc() {\n//            @Override\n//            public void CalcOther(Interfaces.MoveData d) {\n//                if(grab) d.robot.graber.setPosition(0.8);\n//                else d.robot.graber.setPosition(0);\n//            }\n//\n//            @Override\n//            public double myProgress(Interfaces.MoveData d) {\n//                return 0;\n//            }\n//        };\n//    }\n//\n//    public static Interfaces.OtherCalc ResetWobbleButton(){\n//        final float time123 = System.currentTimeMillis();\n//\n//        return new Interfaces.OtherCalc() {\n//\n//            double prog = 0;\n//            boolean run = false;\n//            boolean backUp = true;\n//            @Override\n//            public void CalcOther(Interfaces.MoveData d) {\n//                if(d.manip.back() && backUp) {\n//                    run = true;\n//                    backUp = false;\n//                }\n//                if(!d.manip.back()) backUp = true;\n//                if(run) {\n//                    prog += 0.02;\n//                    if (prog > 0.5) {\n//                        d.robot.wobbleOffset = d.robot.wobble.getCurrentPosition();\n//                        d.robot.wobble.setTargetPosition(3 + d.robot.wobbleOffset);\n//                        d.robot.wobble.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n//                        //                    d.robot.wobbleEx.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n//                        //                    while (d.robot.wobbleEx.getCurrentPosition() == 0) {\n//                        //                    }\n//                        //                    d.robot.wobbleEx.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n//                        run = false;\n//                        prog = 0;\n//                        //\n//                    } else {\n//                        d.robot.wobble.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n//                        d.robot.wobble.setPower(-0.10);\n//\n//                    }\n//                }\n//            }\n//\n//            @Override\n//            public double myProgress(Interfaces.MoveData d) {\n//                return 0;\n//            }\n//        };\n//    }\n//\n//    public static Interfaces.OtherCalc ResetWobble(){\n//        final float time123 = System.currentTimeMillis();\n//\n//        return new Interfaces.OtherCalc() {\n//\n//            double prog = 0;\n//\n//            @Override\n//            public void CalcOther(Interfaces.MoveData d) {\n//                prog += 0.02;\n//                if(prog > 0.5) {\n//                    d.robot.wobbleOffset = d.robot.wobble.getCurrentPosition();\n//                    d.robot.wobble.setTargetPosition(3+d.robot.wobbleOffset);\n//                    d.robot.wobble.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n////                    d.robot.wobbleEx.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n////                    while (d.robot.wobbleEx.getCurrentPosition() == 0) {\n////                    }\n////                    d.robot.wobbleEx.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n//                    prog = 1;\n////\n//                }\n//                else {\n//                    d.robot.wobble.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\n//                    d.robot.wobble.setPower(-0.10);\n//\n//                }\n//            }\n//\n//            @Override\n//            public double myProgress(Interfaces.MoveData d) {\n//                return prog;\n//            }\n//        };\n//    }\n//\n//    public static Interfaces.OtherCalc SetWobblePosition(final int wobblePos){\n//        return new Interfaces.OtherCalc() {\n//            @Override\n//            public void CalcOther(Interfaces.MoveData d) {\n//                d.robot.wobbleEx.setTargetPosition(wobblePos+d.robot.wobbleOffset);\n//            }\n//\n//            @Override\n//            public double myProgress(Interfaces.MoveData d) {\n//                return 0;\n//            }\n//        };\n//    }\n//\n//\n//    public static Interfaces.OtherCalc ExitAtProgress(final double exitProgress){\n//        return new Interfaces.OtherCalc() {\n//            double myProgress;\n//            @Override\n//            public void CalcOther(Interfaces.MoveData d) {\n//                if(d.progress>exitProgress) myProgress = 1;\n//            }\n//\n//            @Override\n//            public double myProgress(Interfaces.MoveData d) {\n//                return myProgress;\n//            }\n//        };\n//    }\n//\n//\n//    public static Interfaces.OtherCalc TapeMeasure(){\n//\n//        return new Interfaces.OtherCalc(){\n//            double myProgress;\n//            @Override\n//            public double myProgress(Interfaces.MoveData d) {\n//                return myProgress;\n//            }\n//\n//            @Override\n//            public void CalcOther(Interfaces.MoveData d) {\n//                if(d.progress > 0.95){\n//                    //d.robot.hooker.setPosition(0.5);\n//                }\n//            }\n//        };\n//    }\n//\n//    public static Interfaces.OtherCalc GetDonutStack(){\n//\n//\n////                    phoneCam.setViewportRenderingPolicy(OpenCvCamera.ViewportRenderingPolicy.OPTIMIZE_VIEW);\n//        return new Interfaces.OtherCalc(){\n////            final StackDeterminationPipeline pipeline = new StackDeterminationPipeline();\n//            double myProgress = 0;\n//            boolean first = true;\n//            @Override\n//            public double myProgress(Interfaces.MoveData d) {\n//                return myProgress;\n//            }\n//\n//            @Override\n//            public void CalcOther(final Interfaces.MoveData d) {\n////                if(first){\n////                    d.robot.yeetCam.setPipeline(pipeline);\n////                    d.robot.yeetCam.setViewportRenderingPolicy(OpenCvCamera.ViewportRenderingPolicy.OPTIMIZE_VIEW);\n////                    d.robot.yeetCam.openCameraDeviceAsync(new OpenCvCamera.AsyncCameraOpenListener()\n////                    {\n////                        @Override\n////                        public void onOpened() {\n////                            d.robot.yeetCam.startStreaming(432, 240, OpenCvCameraRotation.SIDEWAYS_LEFT);\n////                        }\n////                    });\n////                    first = false;\n////                }\n//                d.stackHeight = d.robot.pipeline.getHeight();\n//                myProgress = 1.0;\n//            }\n//        };\n//    }\n//\n//\n//    public static Interfaces.OtherCalc GetXOfGoal(){\n//        return new Interfaces.OtherCalc() {\n//            final GoalPositionPipeline pipeline = new GoalPositionPipeline();\n//            boolean first = true;\n//            @Override\n//            public void CalcOther(final Interfaces.MoveData d) {\n//\n//\n//                d.goalBox = pipeline.getPos();\n//                d.hsvValues = pipeline.hsvValues();\n//                if(first){\n//\n//                    d.robot.yeetCam.setPipeline(pipeline);\n//                    d.robot.yeetCam.setViewportRenderingPolicy(OpenCvCamera.ViewportRenderingPolicy.OPTIMIZE_VIEW);\n//                    d.robot.yeetCam.openCameraDeviceAsync(new OpenCvCamera.AsyncCameraOpenListener()\n//                    {\n//                        @Override\n//                        public void onOpened() {\n//                            d.robot.yeetCam.startStreaming(320, 240, OpenCvCameraRotation.SIDEWAYS_LEFT);//320 240\n//                        }\n//                    });\n//                    first = false;\n//                }\n//            }\n//\n//            @Override\n//            public double myProgress(Interfaces.MoveData d) {\n//                return 0;\n//            }\n//        };\n//    }\n//\n//    public static Interfaces.OtherCalc GetPowerPositions(){\n//        return new Interfaces.OtherCalc() {\n//            final PowerShotPositionPipeline pipeline = new PowerShotPositionPipeline();\n//            boolean first = true;\n//            @Override\n//            public void CalcOther(final Interfaces.MoveData d) {\n//                d.powerCenter = pipeline.getPowerCenter();\n//                if(first){\n//                    d.robot.yeetCam.setPipeline(pipeline);\n//                    d.robot.yeetCam.setViewportRenderingPolicy(OpenCvCamera.ViewportRenderingPolicy.OPTIMIZE_VIEW);\n//                    d.robot.yeetCam.openCameraDeviceAsync(new OpenCvCamera.AsyncCameraOpenListener()\n//                    {\n//                        @Override\n//                        public void onOpened() {\n//                            d.robot.yeetCam.startStreaming(1280, 720, OpenCvCameraRotation.SIDEWAYS_LEFT);//320 240 //1280 was 960\n//                        }\n//                    });\n//                    first = false;\n//                }\n//            }\n//\n//            @Override\n//            public double myProgress(Interfaces.MoveData d) {\n//                return 0;\n//            }\n//        };\n//    }\n//\n//    public static Interfaces.OtherCalc SingleShot(final double delay, final double firstDelay){\n//\n//        return new Interfaces.OtherCalc() {\n////            TimeUtil time = new TimeUtil();\n////            TimeUtil time1 = new TimeUtil();\n//            double startTime = System.currentTimeMillis(); //+ 1000;\n//            boolean prog = false;\n//            boolean first = true;\n//            int i = 0;\n//            @Override\n//            public void CalcOther(Interfaces.MoveData d) {\n////                time.startTimer(delay);\n//                d.aimToPowerOverride = true;\n////                if(first) {\n////                    d.robot.pusher.setPosition(0.0);\n////                    d.robot.bucket.setPosition(0.24);\n////                    d.robot.shooterEx.setVelocity(1550);//1500\n////                    first = false;\n////                }\n////                if(Math.abs(d.powerError) < 20.0 && (System.currentTimeMillis() - startTime) > delay){\n////                    d.robot.pusher.setPosition(1.0);\n////                    if((System.currentTimeMillis() - startTime) > (delay + 500)) {\n////                        startTime = System.currentTimeMillis();\n////                        d.robot.pusher.setPosition(0.0);\n////                        i++;\n////                    }\n////                }\n////                if(i > 2){\n////                    prog = true;\n////                    d.aimToPowerOverride = false;\n////                    d.robot.shooterEx.setVelocity(0.0);\n////                    d.robot.pusher.setPosition(0.0);\n////                }\n//                if(i <= 2) {\n//                    if (System.currentTimeMillis() - startTime < delay + (first?firstDelay:0.0)) {\n//                        d.robot.pusher.setPosition(0.0);\n//                        d.robot.bucket.setPosition(0.24);\n//                        d.robot.shooterEx.setVelocity(1550);//1500\n//                    } else {\n//                        d.robot.pusher.setPosition(1.0);\n//                    }\n//                    if (System.currentTimeMillis() - startTime > delay + 1000.0 + (first?firstDelay:0.0)) {\n//                        i++;\n//                        startTime = System.currentTimeMillis();\n//                        d.aimToPowerOverride = false;\n//                        first = false;\n//                        d.robot.pusher.setPosition(0.0);\n//                    }\n//                } else {\n//                    prog = true;\n//                    d.robot.shooterEx.setVelocity(0.0);\n//                }\n//            }\n//\n//            @Override\n//            public double myProgress(Interfaces.MoveData d) {\n//                return prog?1:0;\n//            }\n//        };\n//    }\n////    public static Interfaces.OtherCalc GetDonutStack(final HardwareMap hw, final Telemetry telemetry){\n////\n////            class MyDonutStackOtherCalc implements Interfaces.OtherCalc{\n////                telemetry.addData();\n////\n////                final StackDeterminationPipeline pipeline = new StackDeterminationPipeline();\n////                public MyDonutStackOtherCalc(){\n////                    phoneCam.setPipeline(pipeline);\n////                    phoneCam.setViewportRenderingPolicy(OpenCvCamera.ViewportRenderingPolicy.OPTIMIZE_VIEW);\n////\n////                    phoneCam.openCameraDeviceAsync(new OpenCvCamera.AsyncCameraOpenListener()\n////                    {\n////                        @Override\n////                        public void onOpened() {\n////                            phoneCam.startStreaming(320, 240, OpenCvCameraRotation.SIDEWAYS_LEFT);\n////                        }\n////                    });\n////                }\n////\n////\n////                @Override\n////                public void CalcOther(Interfaces.MoveData d) {\n////\n////                    d.stackHeight = pipeline.getHeight();\n////                    // We set the viewport policy to optimized view so the preview doesn't appear 90 deg\n////                    // out when the RC activity is in portrait. We do our actual image processing assuming\n////                    // landscape orientation, though.\n////\n////                }\n////\n////                @Override\n////                public double myProgress(Interfaces.MoveData d) {\n////                    return 0;\n////                }\n////            }\n////            return new MyDonutStackOtherCalc();\n////    }\n    public static Interfaces.OtherCalc Arm(){\n\n\n        return new Interfaces.OtherCalc(){\n            private double myProgress = 0;\n            @Override\n            public double myProgress(Interfaces.MoveData d) {\n                return myProgress;\n            }\n\n            @Override\n            public void CalcOther(Interfaces.MoveData d){\n                d.robot.barmEx.setVelocity(1500*(-d.manip.ls().x/2.5));\n                d.robot.tarmEx.setVelocity(1500*(-d.manip.ls().y/2.5));\n                d.robot.sarm.setPower(-d.manip.rs().x/2.5);\n            }\n        };\n    }\n\n    public static Interfaces.OtherCalc Claw(){\n\n        return new Interfaces.OtherCalc() {\n\n            double clawPosition = 0.5;\n            @Override\n            public void CalcOther(Interfaces.MoveData d) {\n                if(d.tarmAngle > 90.0){\n                    clawPosition = 0.4* (180-d.tarmAngle)/90.0 + 0.6;\n                } else {\n                    clawPosition = -0.4* d.tarmAngle/90.0+0.6;\n                }\n                d.robot.grip.setPosition(d.manip.rt()/2.0 +.5);\n//                if(d.manip.u()) clawPosition += .05;\n//                else if (d.manip.d()) clawPosition -= .05;\n                d.telemetry.addData(\"claw position\", clawPosition);\n                d.robot.claw.setPosition(clawPosition);//min .2 max 1 center .6\n            }\n\n            @Override\n            public double myProgress(Interfaces.MoveData d) {\n                return 0;\n            }\n        };\n    }\n\n    public static Interfaces.OtherCalc Arm2D(){\n\n\n        return new Interfaces.OtherCalc(){\n            private double myProgress = 0;\n            @Override\n            public double myProgress(Interfaces.MoveData d) {\n                return myProgress;\n            }\n\n            @Override\n            public void CalcOther(Interfaces.MoveData d){\n                d.arm.setArm2DVelocity(d.manip.ls().x, d.manip.ls().y, d.manip.rs().x);\n//                d.arm.thetaVelocity(d.manip.rs().x);\n            }\n        };\n    }\n\n\n\n\n\n    public static Interfaces.OtherCalc ArmPath(final Vector<SpeedCalcs.ProgressSpeed> speeds, final Vector<Vector3D> points){\n\n        return new Interfaces.OtherCalc(){\n            private double myProgress = 0;\n            private boolean first = true;\n            @Override\n            public double myProgress(Interfaces.MoveData d) {\n                return myProgress;\n            }\n\n            @Override\n            public void CalcOther(Interfaces.MoveData d){\n                if(first){\n                    d.arm.setArmPath(points);\n                    d.arm.setProgressSpeeds(speeds);\n                }\n                if(d.manip.b()){\n//                    d.arm.move();\n                } else {\n                    d.robot.tarmEx.setVelocity(0);\n                    d.robot.barmEx.setVelocity(0);\n                    d.robot.sarmEx.setVelocity(0);\n                }\n//                d.robot.barmEx.setVelocity(1500*(-d.manip.ls().x/2.5));\n//                d.robot.tarmEx.setVelocity(1500*(-d.manip.ls().y/2.5));\n//                d.robot.sarm.setPower(-d.manip.rs().x/2.5);\n            }\n        };\n    }\n\n    public static Interfaces.OtherCalc Duck(){\n\n\n        return new Interfaces.OtherCalc(){\n            private double myProgress = 0;\n            @Override\n            public double myProgress(Interfaces.MoveData d) {\n                return myProgress;\n            }\n\n            @Override\n            public void CalcOther(Interfaces.MoveData d){\n                d.robot.duck.setPower(d.manip.lt()-d.manip.rt());\n            }\n        };\n    }\n\n\n    public static Interfaces.OtherCalc TeleOpMatch(){\n\n        final TimeUtil matchTime = new TimeUtil();\n        final TimeUtil endGameTime = new TimeUtil();\n\n        return new Interfaces.OtherCalc(){\n            private double myProgress;\n            private boolean firstLoop = true;\n            @Override\n            public double myProgress(Interfaces.MoveData d) {\n                return myProgress;\n            }\n\n            @Override\n            public void CalcOther(Interfaces.MoveData d){\n                if(firstLoop){\n                    endGameTime.startTimer(120000);\n                    matchTime.startTimer(150000);\n                    firstLoop=false;\n                }\n\n                d.timeRemainingUntilEndgame = endGameTime.timeRemaining();\n                d.timeRemainingUntilMatch = matchTime.timeRemaining();\n                myProgress = 1-(d.timeRemainingUntilMatch/150000);\n\n            }\n        };\n    }\n\n\n    public static Interfaces.OtherCalc TelemetryPosition(){\n        return new Interfaces.OtherCalc() {\n            protected int stringFieldWidth = 24;\n            protected int stringFieldHeight = 16;\n            @Override\n            public void CalcOther(Interfaces.MoveData d) {\n                int realFieldWidth = 366;\n                int realFieldHeight = 366;\n                int adjustedColumn = (int)Math.round((d.wPos.x/realFieldWidth)* stringFieldWidth);\n                int adjustedRow = (int)Math.round((d.wPos.y/realFieldHeight)* stringFieldHeight);\n                String rval = \"\";\n                for(int row = stringFieldHeight-1; row>-1; row--){\n                    if(row == stringFieldHeight-1) rval += \"\\u2004______________________________________________\\n\";\n                    rval += \"|\";\n\n                    for(int col = 0; col< stringFieldWidth; col++){\n\n                        if(row == adjustedRow && col == adjustedColumn){\n                            rval += \"■\";\n                        } else {\n                            rval += \"\\u2004\\u2002\";\n                        }\n\n                        if(col == stringFieldWidth-1) {\n                            if (row == 0) {\n                                rval += \"|\";\n                            } else {\n                                rval += \"|\\n\";\n                            }\n                        }\n\n                    }\n                }\n                rval += \"_______________________________________________\\u2004\";\n                d.field = rval;\n            }\n\n            @Override\n            public double myProgress(Interfaces.MoveData d) {\n                return 0;\n            }\n        };\n    }\n\n\n    public static Interfaces.OtherCalc TeleSafe(){\n        return new Interfaces.OtherCalc() {\n            @Override\n            public void CalcOther(Interfaces.MoveData d) {\n                /*if(!d.manip.isConnected() && !d.driver.isConnected()) {\n                    System.out.println(\"your skrewed\");\n                } else{\n                    if(!d.manip.isConnected()) {\n                        System.out.println(\"yes\");\n                    }\n                    else if(!d.driver.isConnected()) {\n                        System.out.println(\"no\");\n                    }\n                    else {\n                        System.out.println(\"perfect\");\n                    }\n                }*/\n\n            }\n\n            @Override\n            public double myProgress(Interfaces.MoveData d) {\n                return 0;\n            }\n        };\n    }\n\n\n    public static Interfaces.OtherCalc AutoOpMatch(){\n        final TimeUtil autoTime = new TimeUtil();\n\n        return new Interfaces.OtherCalc() {\n            private double myProgress;\n            protected int timeInAuto = 30_000;\n            private boolean firstLoop = true;\n            @Override\n            public void CalcOther(Interfaces.MoveData d) {\n                if(firstLoop){\n                    autoTime.startTimer(timeInAuto);\n                    firstLoop = false;\n                }\n                myProgress = 1-(autoTime.timeRemaining()/timeInAuto);\n            }\n\n            @Override\n            public double myProgress(Interfaces.MoveData d) {\n                return myProgress;\n            }\n        };\n\n    }\n\n\n    public static Interfaces.OtherCalc DistanceStop(final Side side, final double startStopDist, final double stopStopDist, final double startProgress, final double endProgress){\n\n        return new Interfaces.OtherCalc(){\n            private double myProgress = 0;\n            @Override\n            public double myProgress(Interfaces.MoveData d) {\n                return myProgress;\n            }\n\n            @Override\n            public void CalcOther(Interfaces.MoveData d){\n//                switch(side) {\n//                    case FRONT:\n//                        if (startStopDist < d.robot.frontRange.getDistance(DistanceUnit.CM)) {\n//                            myProgress = 0;\n//                        } else if (startStopDist > d.robot.frontRange.getDistance(DistanceUnit.CM)) {\n//                            myProgress = startProgress + (endProgress - startProgress) * ((startStopDist - d.robot.frontRange.getDistance(DistanceUnit.CM))\n//                                    / (startStopDist - stopStopDist));\n//                        } else if (stopStopDist > d.robot.frontRange.getDistance(DistanceUnit.CM)) {\n//                            myProgress = endProgress;\n//                        }\n//                        break;\n//                    case BACK:\n//                        if (startStopDist < d.robot.backRange.getDistance(DistanceUnit.CM)){\n//                            myProgress = 0;\n//                        } else if (startStopDist > d.robot.backRange.getDistance(DistanceUnit.CM)) {\n//                            myProgress = startProgress + (endProgress - startProgress) * ((startStopDist - d.robot.backRange.getDistance(DistanceUnit.CM))\n//                                    / (startStopDist - stopStopDist));\n//                        } else if (stopStopDist > d.robot.backRange.getDistance(DistanceUnit.CM)) {\n//                            myProgress = endProgress;\n//                        }\n//                        break;\n//                    case RIGHT:\n////                        if (startStopDist < d.robot.rightRange.getDistance(DistanceUnit.CM)) {\n////                            myProgress = 0;\n////                        } else if (startStopDist > d.robot.rightRange.getDistance(DistanceUnit.CM)) {\n////                            myProgress = startProgress + (endProgress - startProgress) * ((startStopDist - d.robot.rightRange.getDistance(DistanceUnit.CM))\n////                                    / (startStopDist - stopStopDist));\n////                        } else if (stopStopDist > d.robot.rightRange.getDistance(DistanceUnit.CM)) {\n////                            myProgress = endProgress;\n////                        }\n//                        break;\n//                    case LEFT:\n////                        if (startStopDist < d.robot.leftRange.getDistance(DistanceUnit.CM)) {\n////                            myProgress = 0;\n////                        } else if (startStopDist > d.robot.leftRange.getDistance(DistanceUnit.CM)) {\n////                            myProgress = startProgress + (endProgress - startProgress) * ((startStopDist - d.robot.leftRange.getDistance(DistanceUnit.CM))\n////                                    / (startStopDist - stopStopDist));\n////                        } else if (stopStopDist > d.robot.leftRange.getDistance(DistanceUnit.CM)) {\n////                            myProgress = endProgress;\n////                        }\n//                        break;\n//                }\n            }\n        };\n    }\n\n\n//    public static Interfaces.OtherCalc TimeProgress(){\n//\n//        TimeUtil matchTime = new TimeUtil();\n//        TimeUtil endGameTime = new TimeUtil();\n//\n//        return new Interfaces.OtherCalc(){\n//            @Override\n//            public double myProgress(Interfaces.MoveData d) {\n//                return true;\n//            }\n//\n//            @Override\n//            public void CalcOther(Interfaces.MoveData d){\n//                if(d.firstLoop){\n//                    endGameTime.startTimer(120000);\n//                    matchTime.startTimer(150000);\n//                    d.firstLoop=false;\n//                }\n//\n//                d.timeRemainingUntilEndgame = endGameTime.timeRemaining();\n//                d.timeRemainingUntilMatch = matchTime.timeRemaining();\n//                d.progress = 1-(d.timeRemainingUntilMatch/150000);\n//\n//            }\n//        };\n//    }\n\n\n    public enum Controller{\n        DRIVER,\n        MANIP\n    }\n\n    public enum Side {\n        FRONT,\n        BACK,\n        RIGHT,\n        LEFT\n    }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Calculators/OtherCalcs.java	(revision 41983f78e90897951c2ad4db0f0ea7dce802dc80)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Calculators/OtherCalcs.java	(date 1638221702000)
@@ -45,6 +45,7 @@
         };
     }
 
+
 //    public static Interfaces.OtherCalc Bucket(){
 //
 //        return new Interfaces.OtherCalc(){
@@ -853,6 +854,24 @@
         };
     }
 
+    public static Interfaces.OtherCalc ClawCubeGrab(){
+        return new Interfaces.OtherCalc() {
+            @Override
+            public void CalcOther(Interfaces.MoveData d) {
+                if(d.robot.cubeFindPipeline.cubeSize()>50000){
+                    d.robot.grip.setPosition(0.5);
+                } else {
+                    d.robot.grip.setPosition(1.0);
+                }
+            }
+
+            @Override
+            public double myProgress(Interfaces.MoveData d) {
+                return 0;
+            }
+        };
+    }
+
     public static Interfaces.OtherCalc Duck(){
 
 
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Hardware/FreightRobotName_NA/RobotMap.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.Hardware.FreightRobotName_NA;\n\nimport com.qualcomm.hardware.bosch.BNO055IMU;\nimport com.qualcomm.hardware.modernrobotics.ModernRoboticsI2cRangeSensor;\nimport com.qualcomm.robotcore.hardware.*;\nimport com.qualcomm.robotcore.hardware.configuration.typecontainers.MotorConfigurationType;\nimport com.vuforia.Vuforia;\nimport org.firstinspires.ftc.robotcore.external.hardware.camera.WebcamName;\nimport org.firstinspires.ftc.teamcode.Hardware.Sensors.CubeFindPipeline;\nimport org.openftc.easyopencv.OpenCvCamera;\nimport org.openftc.easyopencv.OpenCvCameraFactory;\nimport org.openftc.easyopencv.OpenCvCameraRotation;\nimport org.openftc.easyopencv.OpenCvInternalCamera;\n//import org.firstinspires.ftc.teamcode.Hardware.Sensors.Camera;\n//import org.firstinspires.ftc.teamcode.Hardware.Sensors.NavX;\n//import org.firstinspires.ftc.teamcode.Hardware.Sensors.VexEncoder;\n//import org.firstinspires.ftc.teamcode.Hardware.Sensors.StackDeterminationPipeline;\n\n//import org.openftc.easyopencv.OpenCvCamera;\n//import org.openftc.easyopencv.OpenCvCameraFactory;\n//import org.openftc.easyopencv.OpenCvCameraRotation;\n//import org.openftc.easyopencv.OpenCvInternalCamera;\n//\nimport com.spartronics4915.lib.T265Camera;\nimport com.arcrobotics.ftclib.geometry.Pose2d;\nimport com.arcrobotics.ftclib.geometry.Rotation2d;\nimport com.arcrobotics.ftclib.geometry.Transform2d;\nimport com.arcrobotics.ftclib.geometry.Translation2d;\n\n\npublic class RobotMap {\n\n    public static DcMotor bright, fright, bleft, fleft, barm, tarm, sarm, duck;//, shooter, intake, wobble;\n\n//    public static int wobbleOffset = 0;\n\n    public static DcMotorEx brightEx, frightEx, bleftEx, fleftEx, barmEx, tarmEx, sarmEx, duckEx;//, shooterEx, intakeEx, wobbleEx;\n\n    public static DigitalChannel bop, top;\n\n    public static Servo grip, claw;\n//    public static Servo bucket, pusher, graber;\n\n//    public static CRServo vex;\n\n    public static BNO055IMU gyro;\n\n    //public static VexEncoder vexCrap;\n\n//    public static OpenCvInternalCamera yeetCam;\n\n//    public static OpenCvInternalCamera ClawCam;\n\n//    public final StackDeterminationPipeline pipeline = new StackDeterminationPipeline();\n\n//    public static T265Camera slamra = null;\n    public static OpenCvCamera clawCam;\n\n    public static HardwareMap hw;\n\n    //public static ModernRoboticsI2cRangeSensor frontRange, backRange;\n\n    public RobotMap(HardwareMap hw){//, Interfaces.MoveData.StartData posh) {\n\n        this.hw = hw;\n        /**\n         * @see <a href=\"https://ftc-tricks.com/dc-motors/\"</a>\n         * @see DcMotor.RunMode.RUN_USING_ENCODER this implements a PID for all of the motors\n         * This elminates the problems such as the inconsistent auto and having to charge the battery to full every use\n         * @see DcMotorSimple.Direction.REVERSE is the correct place to change the directions of the motors\n         * it should not be done in a higher level code this is the correct spot\n         */\n//PIDCoefficients pidDrive = new PIDCoefficients(50, 10, 0);\n        PIDFCoefficients pidDrive = new PIDFCoefficients(20, 12, 5, 17.5);//p5 i2 d5 f17.5\n        PIDFCoefficients pidBarm = new PIDFCoefficients(20, 5, 0, 17.5);//p5 i2 d5 f17.5\n        PIDFCoefficients pidTarm = new PIDFCoefficients(20, 0, 2.5, 30);//p5 i2 d5 f17.5\n\n        bright = hw.get(DcMotor.class, \"bright\");\n        bright.setDirection(DcMotorSimple.Direction.REVERSE);\n        //RUN_USING_ENCODER gives each motor a PID and ensures the motors run at the same speed every time.\n        bright.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        bright.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        bright.setDirection(DcMotorSimple.Direction.REVERSE);\n        bright.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        brightEx = (DcMotorEx) bright;\n        brightEx.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, pidDrive);\n\n        fright = hw.get(DcMotor.class, \"fright\");\n        fright.setDirection(DcMotorSimple.Direction.REVERSE);\n        fright.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        fright.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        fright.setDirection(DcMotorSimple.Direction.REVERSE);\n        fright.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        frightEx = (DcMotorEx) fright;\n        frightEx.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, pidDrive);\n\n        bleft = hw.get(DcMotor.class, \"bleft\");\n        bleft.setDirection(DcMotorSimple.Direction.FORWARD);\n        bleft.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        bleft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        bleft.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        bleftEx = (DcMotorEx) bleft;\n        bleftEx.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, pidDrive);\n\n        fleft = hw.get(DcMotor.class, \"fleft\");\n        fleft.setDirection(DcMotorSimple.Direction.FORWARD);\n        fleft.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        fleft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        fleft.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        fleftEx = (DcMotorEx) fleft;\n        fleftEx.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, pidDrive);\n\n        barm = hw.get(DcMotor.class, \"barm\");\n        barm.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        barm.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        barm.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        barmEx = (DcMotorEx) barm;\n        barmEx.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, pidBarm);\n\n        tarm = hw.get(DcMotor.class, \"tarm\");\n        tarm.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        tarm.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        tarm.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        tarmEx = (DcMotorEx) tarm;\n        tarmEx.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, pidTarm);\n\n        sarm = hw.get(DcMotor.class, \"sarm\");\n        sarm.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\n        sarm.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n        sarm.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\n        sarmEx = (DcMotorEx) sarm;\n        sarmEx.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, pidDrive);\n\n        duck = hw.get(DcMotor.class, \"duck\");\n\n//        intake = hw.get(DcMotor.class, \"intake\");\n//        intake.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n//        intake.setDirection(DcMotorSimple.Direction.REVERSE);\n//        intakeEx = (DcMotorEx) intake;\n//        intakeEx.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, new PIDFCoefficients(15, 3, 1, 18));\n////        PIDCoefficients pidNewIntake = new PIDCoefficients(10, 6, 50);\n////        shooterEx.setPIDCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, pidNewIntake);\n//\n//        shooter = hw.get(DcMotor.class, \"shooter\");\n//        shooter.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\n//        shooter.setDirection(DcMotorSimple.Direction.REVERSE);\n//        final double NEW_P_YEET = 240.0;//5.0345;//4.510599773831102;\n//        final double NEW_I_YEET = 50.0;//0.3631;//15.424780949509735;\n//        final double NEW_D_YEET = 10.0000;\n//        shooterEx  = (DcMotorEx)shooter;\n////        int motorIndexYeet = ((DcMotorEx)shooter).getPortNumber();\n////        shooterEx.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, new PIDFCoefficients(2.12, 5.51, 0, 14));\n////        shooterEx.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, new PIDFCoefficients(0, 0, 0, 14));\n//        PIDCoefficients pidNewYeet = new PIDCoefficients(NEW_P_YEET, NEW_I_YEET, NEW_D_YEET);\n//        shooterEx.setPIDCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, pidNewYeet);\n//\n//        wobble = hw.get(DcMotor.class, \"wobble\");\n//        wobble.setTargetPosition(3);\n//        wobbleOffset = wobble.getCurrentPosition();\n//        wobble.setTargetPosition(wobbleOffset);\n//        wobble.setMode(DcMotor.RunMode.RUN_TO_POSITION);\n//\n//        wobbleEx = (DcMotorEx) wobble;\n//        wobbleEx.setVelocity(500);//400\n//\n//        final double NEW_P = 12;\n//        final double NEW_I = 6;\n//        final double NEW_D = 0.2;\n//        DcMotorControllerEx motorControllerEx = (DcMotorControllerEx)wobble.getController();\n//        int motorIndex = ((DcMotorEx)wobble).getPortNumber();\n//        PIDCoefficients pidNew = new PIDCoefficients(NEW_P, NEW_I, NEW_D);\n//        motorControllerEx.setPIDCoefficients(motorIndex, DcMotor.RunMode.RUN_USING_ENCODER, pidNew);\n\n\n        bop = hw.get(DigitalChannel.class, \"bop\");\n\n        // set the digital channel to input.\n        bop.setMode(DigitalChannel.Mode.INPUT);\n\n        top = hw.get(DigitalChannel.class, \"top\");\n\n        // set the digital channel to input.\n        top.setMode(DigitalChannel.Mode.INPUT);\n\n        /**\n         * @see NavX is constructed with the heading from the beginning of an {@link org.firstinspires.ftc.teamcode.ftc10650.Auto} and\n         * {@link org.firstinspires.ftc.teamcode.ftc10650.Tele}\n         */\n        //gyro = new NavX(hw, \"navX\",startHeading);\n\n        gyro = hw.get(BNO055IMU.class, \"imu\");\n        BNO055IMU.Parameters parameters = new BNO055IMU.Parameters();\n\n        parameters.mode                = BNO055IMU.SensorMode.IMU;\n        parameters.angleUnit           = BNO055IMU.AngleUnit.DEGREES;\n        parameters.accelUnit           = BNO055IMU.AccelUnit.METERS_PERSEC_PERSEC;\n        parameters.loggingEnabled      = false;\n\n        gyro.initialize(parameters);\n\n\n        //vexCrap = hw.get(VexEncoder.class, \"vexCrap\");\n\n\n        /**\n         * the servos are not currently in use but this is where the would be initialized\n         */\n        grip = hw.get(Servo.class, \"grip\");\n        claw = hw.get(Servo.class, \"claw\");\n//        bucket = hw.get(Servo.class, \"bucket\");\n//        pusher = hw.get(Servo.class, \"pusher\");\n//        graber = hw.get(Servo.class, \"graber\");\n//\n//        vex = hw.get(CRServo.class, \"vexLift\");\n\n\n        /**\n         * @see frontRange the front of the robots {@link ModernRoboticsI2cRangeSensor} distance sensor\n         * @see backRange the back of the robots {@link ModernRoboticsI2cRangeSensor} distance sensor\n         * it is expected to add the other sides of the robot later\n         */\n        //frontRange = hw.get(ModernRoboticsI2cRangeSensor.class, \"frontRange\");\n        //backRange  = hw.get(ModernRoboticsI2cRangeSensor.class, \"backRange\");\n//        int cameraMonitorViewId = hw.appContext.getResources().getIdentifier(\"cameraMonitorViewId\", \"id\", hw.appContext.getPackageName());\n//        yeetCam = OpenCvCameraFactory.getInstance().createInternalCamera(OpenCvInternalCamera.CameraDirection.BACK, cameraMonitorViewId);\n//\n//\n//\n//        yeetCam.setPipeline(pipeline);\n//        yeetCam.setViewportRenderingPolicy(OpenCvCamera.ViewportRenderingPolicy.OPTIMIZE_VIEW);\n//                    yeetCam.openCameraDeviceAsync(new OpenCvCamera.AsyncCameraOpenListener()\n//                    {\n//                        @Override\n//                        public void onOpened() {\n//                            yeetCam.startStreaming(432, 240, OpenCvCameraRotation.SIDEWAYS_LEFT);\n//                        }\n//                    });\n      //  yeetCam.initVuforia(hw, true);\n        //yeetCam = hw.get(WebcamName.class, \"yeetCam\");\n\n//        int cameraMonitorViewId = hw.appContext.getResources().getIdentifier(\"cameraMonitorViewId\", \"id\", hw.appContext.getPackageName());\n//        ClawCam = OpenCvCameraFactory.getInstance().createInternalCamera(OpenCvInternalCamera.CameraDirection.BACK, cameraMonitorViewId);\n//        ClawCam.openCameraDeviceAsync(\n//                new OpenCvCamera.AsyncCameraOpenListener() {\n//                    @Override\n//                    public void onOpened() {\n//                        ClawCam.startStreaming(1920, 1080);\n//                    }\n//\n//                    @Override\n//                    public void onError(int errorCode) {\n//\n//                    }\n//                }\n//        );\n        int cameraMonitorViewId = hw.appContext.getResources().getIdentifier(\"cameraMonitorViewId\", \"id\", hw.appContext.getPackageName());\n        WebcamName webcamName = hw.get(WebcamName.class, \"ClawCam\");\n        clawCam = OpenCvCameraFactory.getInstance().createWebcam(webcamName, cameraMonitorViewId);\n        clawCam.openCameraDeviceAsync(\n                new OpenCvCamera.AsyncCameraOpenListener() {\n                    @Override\n                    public void onOpened() {\n                        clawCam.startStreaming(1920, 1080, OpenCvCameraRotation.UPRIGHT);\n                        clawCam.setPipeline(new CubeFindPipeline());\n                    }\n\n                    @Override\n                    public void onError(int errorCode) {\n\n                    }\n                }\n        );\n//        if (slamra == null) {\n//            //set offset from center of robot here\n//            slamra = new T265Camera(new Transform2d(new Translation2d(0, 0), new Rotation2d()), 1.0, hw.appContext);//oC was 0.1\n//\n//        }\n\n\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Hardware/FreightRobotName_NA/RobotMap.java	(revision 41983f78e90897951c2ad4db0f0ea7dce802dc80)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Hardware/FreightRobotName_NA/RobotMap.java	(date 1638220440000)
@@ -53,6 +53,8 @@
 
 //    public final StackDeterminationPipeline pipeline = new StackDeterminationPipeline();
 
+    public final CubeFindPipeline cubeFindPipeline = new CubeFindPipeline();
+
 //    public static T265Camera slamra = null;
     public static OpenCvCamera clawCam;
 
@@ -261,7 +263,7 @@
                     @Override
                     public void onOpened() {
                         clawCam.startStreaming(1920, 1080, OpenCvCameraRotation.UPRIGHT);
-                        clawCam.setPipeline(new CubeFindPipeline());
+                        clawCam.setPipeline(cubeFindPipeline);
                     }
 
                     @Override
Index: .idea/compiler.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"CompilerConfiguration\">\n    <bytecodeTargetLevel target=\"11\" />\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/compiler.xml	(revision 41983f78e90897951c2ad4db0f0ea7dce802dc80)
+++ .idea/compiler.xml	(date 1638217516000)
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
   <component name="CompilerConfiguration">
-    <bytecodeTargetLevel target="11" />
+    <bytecodeTargetLevel target="1.8" />
   </component>
 </project>
\ No newline at end of file
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Op/ComplexOp.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.Op;\n\nimport com.arcrobotics.ftclib.geometry.Pose2d;\nimport com.qualcomm.robotcore.hardware.*;\n\nimport org.firstinspires.ftc.teamcode.Calculators.OtherCalcs;\n//import org.firstinspires.ftc.teamcode.Hardware.Sensors.Camera;\nimport org.firstinspires.ftc.teamcode.Hardware.FreightRobotName_NA.RobotMap;\nimport org.firstinspires.ftc.teamcode.Utilities.*;\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\n\nimport org.firstinspires.ftc.teamcode.Calculators.Interfaces;\nimport org.firstinspires.ftc.teamcode.Hardware.Sensors.CompleteController;\nimport org.firstinspires.ftc.teamcode.Hardware.MecanumDrive;\n\nimport java.net.*;\n\npublic abstract class ComplexOp extends LinearOpMode{\n\n    private MecanumDrive mecanumDrive;\n\n    double previousHeading = 0;\n\n    private Pose2d initPose = null;\n\n    public void ComplexMove(Interfaces.SpeedCalc speedCalc,\n                            Interfaces.MotionCalc motionCalc,\n                            Interfaces.OrientationCalc orientationCalc,\n                            Interfaces.OtherCalc... otherCalc) throws InterruptedException {\n\n        d.progress = 0;\n\n        Vector2D vector = new Vector2D();\n\n        float endGameTime = 0;\n\n        d.lastCommand = d.currentCommand;\n        d.currentCommand = new Interfaces.MoveData.Command(0, vector,0.0);\n        DatagramSocket ds = null;\n        try {\n            ds = new DatagramSocket();\n        } catch (SocketException e) {\n            e.printStackTrace();\n        }\n//        if(initPose == null) initPose = d.robot.slamra.getLastReceivedCameraUpdate().pose;\n        while(d.progress < 1.0) {\n            //_______________________\n//            if(ds != null) {\n//                InetAddress ip = null;\n//                try {\n//                    ip = InetAddress.getByName(\"192.168.43.255\");\n//                    //ip = InetAddress.getLocalHost();\n//                } catch (UnknownHostException e) {\n//                    e.printStackTrace();\n//                }\n//                String str = String.valueOf(System.currentTimeMillis())+\":\"+String.valueOf(Math.abs(d.robot.intakeEx.getVelocity())+\":\"+Double.toString(d.intakeCommand));\n//                byte[] strBytes = str.getBytes();\n//                DatagramPacket DpSend =\n//                        new DatagramPacket(strBytes, strBytes.length, ip, 10650);\n//                try {\n//                    ds.send(DpSend);\n//                } catch (IOException e) {\n//                    e.printStackTrace();\n//                }\n//            }\n            //_______________________\n\n\n//            Orientation orientation = d.robot.gyro.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.XYZ, AngleUnit.DEGREES);\n//            double heading = orientation.thirdAngle-d.startData.StartHeading;\n//            double diffHeading = heading - previousHeading;\n//            if(diffHeading > 180.0) {\n//                diffHeading -= 360.0;\n//            } else if (diffHeading <= -180.0){\n//                diffHeading += 360.0;\n//            }\n//            d.heading += diffHeading;\n//            previousHeading = heading;\n\n//            telemetry.addData(\"gryo\", orientation.thirdAngle);\n//            telemetry.addData(\"orientation\", d.heading);\n//            Vector2D encoderPre = d.encoderPos.clone();\n//            d.encoderPos = mecanumDrive.getVectorDistanceCm();\n//            Vector2D deltaMove = d.encoderPos.getSubtracted(encoderPre);\n//            deltaMove.rotateBy(Math.toRadians(d.heading));//WAS -d.heading !!!!!!!!!!!!!!!!!!!!\n//            d.preWPos.set(d.wPos);\n//            d.wPos.add(deltaMove);\n\n//            Vector2D slamraPos = new Vector2D(\n//                    (d.robot.slamra.getLastReceivedCameraUpdate().pose.getTranslation().getX()-initPose.getTranslation().getX())*100.0,\n//                    (d.robot.slamra.getLastReceivedCameraUpdate().pose.getTranslation().getY()-initPose.getTranslation().getY())*100.0);\n\n//            slamraPos.rotateBy(Math.toRadians(startPositionAndOrientation().StartNorthOffset));\n//            slamraPos.add(startPositionAndOrientation().StartPos);\n//            d.wPos.set(slamraPos);\n\n//            d.heading = d.robot.slamra.getLastReceivedCameraUpdate().pose.getRotation().getDegrees() - initPose.getRotation().getDegrees();\n\n\n            d.arm.update();\n\n\n            if(orientationCalc != null) d.currentCommand.orientationSpeed = orientationCalc.CalcOrientation(d);\n            if(motionCalc != null) {\n                d.currentCommand.motionSpeed = motionCalc.CalcMotion(d);\n                d.currentCommand.motionSpeed.rotateBy(Math.toRadians(90-d.heading));\n            }\n            if(speedCalc != null) d.currentCommand.speed = speedCalc.CalcSpeed(d);\n\n            for (Interfaces.OtherCalc calc : otherCalc) calc.CalcOther(d);\n\n            if (d.timeRemainingUntilEndgame >= 0) endGameTime = (float)(Math.round(d.timeRemainingUntilEndgame / 100) / 10.0);\n\n            //could add specific telemetry data to show through an implementation of complexOp\n\n            //telemetry.addData(\"Position: (\"+String.valueOf(Math.round(d.wPos.x))+\", \"+String.valueOf(Math.round(d.wPos.y))+\")\", \"\\n\"+d.field);\n            //telemetry.addData(\"heading\", Math.round(d.heading*10)/10.0);\n            //telemetry.addData(\"position\", \" \"+String.valueOf(Math.round(d.wPos.x))+\", \"+String.valueOf(Math.round(d.wPos.y)));\n            /*\n            int z = 0;\n            short[]ss = d.robot.vexCrap.readAll();\n            for(short s: ss){\n                telemetry.addData(\"Vex Encoder Register: \" + z + \": \", s);\n                z++;\n            }\n            */\n//            telemetry.addData(\"manip lx\",d.manip.ls().x);\n//            telemetry.addData(\"manip ly\", d.manip.ls().y);\n//            telemetry.addData(\"manip rx\", d.manip.rs().x);\n//            telemetry.addData(\"manip ry\", d.manip.rs().y);\n//            telemetry.addData(\"x pos\", d.wPos.x);\n//            telemetry.addData(\"y pos\", d.wPos.y);\n//            telemetry.addData(\"right joystick x\", d.driver.rs().x);\n//            telemetry.addData(\"wobble position\", d.robot.wobbleEx.getCurrentPosition());\n//            telemetry.addData(\"offset\", d.robot.wobbleOffset);\n//            telemetry.addData(\"right stick x\", d.driver.rs().x);\n//            telemetry.addData(\"right stick x raw\", gamepad1.right_stick_x);\n//            telemetry.addData(\"bop\", d.robot.barm.getCurrentPosition());\n//            telemetry.addData(\"top\", d.robot.tarm.getCurrentPosition());\n\n//            telemetry.addData(\"barm ticks\", d.robot.barm.getCurrentPosition()-d.initBarmPos);\n//            telemetry.addData(\"tarm ticks\", d.robot.tarm.getCurrentPosition()-d.initTarmPos);\n//            telemetry.addData(\"sarm ticks\", d.robot.sarm.getCurrentPosition()-d.initSarmPos);\n            telemetry.addData(\"barm velocity\", d.debugData1);\n            telemetry.addData(\"tarm velocity\", d.debugData2);\n            telemetry.addData(\"barmAngle\", d.barmAngle);\n            telemetry.addData(\"tarmAngle\", d.tarmAngle);\n            telemetry.addData(\"x\", d.arm.getCartesian().x);\n            telemetry.addData(\"y\", d.arm.getCartesian().y);\n            telemetry.addData(\"z\", d.arm.getCartesian().z);\n\n            //telemetry.addData(\"goal position\", d.goalPosition);\n\n//            telemetry.addData(\"goal position\", d.goalBox);\n\n//            telemetry.addData(\"H\", d.hsvValues[0]);\n//            telemetry.addData(\"S\", d.hsvValues[1]);\n//            telemetry.addData(\"V\", d.hsvValues[2]);\n\n//            telemetry.addData(\"height\", d.powerCenter.x);\n\n\n//            telemetry.addData(\"heading\", d.heading);\n//            telemetry.addData(\"bucket\", d.robot.bucket.getPosition());\n//            telemetry.addData(\"\", d.robot.shooter.getCurrentPosition() - last);\n//            last = d.robot.shooter.getCurrentPosition();\n\n//            telemetry.addData(\"l button\", d.manip.l());\n\n//            DcMotorControllerEx motorControllerEx = (DcMotorControllerEx)d.robot.shooter.getController();\n//            int motorIndex = ((DcMotorEx)d.robot.shooter).getPortNumber();\n//            telemetry.addData(\"P\", motorControllerEx.);\n            //PIDCoefficients pidNew = new PIDCoefficients(NEW_P, NEW_I, NEW_D);\n            //motorControllerEx.setPIDCoefficients(motorIndex, DcMotor.RunMode.RUN_USING_ENCODER, pidNew);\n//            DcMotorEx motorExLeft = (DcMotorEx)hardwareMap.get(DcMotor.class, \"shooter\");\n//            PIDCoefficients pidModified = motorExLeft.getPIDCoefficients(DcMotor.RunMode.RUN_USING_ENCODER);\n//            telemetry.addData(\"P\", pidModified.p);\n//            telemetry.addData(\"I\", pidModified.i);\n//            telemetry.addData(\"D\", pidModified.d);\n//            telemetry.addData(d.robot.shooter.)\n//            telemetry.addData(\"bucket pos\", d.robot.bucket.getPosition());\n//            telemetry.addData(\"pid orig p\", pidOrig.p);\n//            telemetry.addData(\"pid orig i\", pidOrig.i);\n//            telemetry.addData(\"pid orig d\", pidOrig.d);\n//            telemetry.addData(\"Yeetor speed\", d.manip.lt());\n//            telemetry.addData(\"Stack Height\", d.stackHeight);\n//            telemetry.addData(\"Motor Velocity\", d.robot.shooterEx.getVelocity());\n//            telemetry.addData(\"fright Velocity\", d.robot.frightEx.getVelocity());\n            telemetry.addData(\"Robot is here\", \"\\n\"+d.field);\n            telemetry.addData(\"position\", d.wPos.x + \"   \" + d.wPos.y);\n            telemetry.addData(\"heading\", d.heading);\n            telemetry.update();\n\n            //Camera camera = new Camera(hardwareMap,false);\n            //camera.cycle();\n            //d.robot.yeetCam.cycle();\n\n            mecanumDrive.driveMecanum(\n                    d.currentCommand.motionSpeed,\n                    d.currentCommand.speed,\n                    d.currentCommand.orientationSpeed);\n\n\n\n            d.progress = MathUtil.findMaxList(\n                    motionCalc == null ? 0 : motionCalc.myProgress(d),\n                    orientationCalc == null ? 0 : orientationCalc.myProgress(d),\n                    speedCalc == null ? 0 : speedCalc.myProgress(d));\n\n\n            for (Interfaces.OtherCalc calc : otherCalc) d.progress = Math.max(d.progress,calc.myProgress(d));\n\n\n            if (!opModeIsActive()) throw new InterruptedException();\n        }\n    }\n\n    //How data is transferred between calculators and complexOp\n    public Interfaces.MoveData d = new Interfaces.MoveData();//if you delete this the world will end\n\n\n    void initHardware(HardwareMap hwMap) {\n\n        telemetry.addData(\"ENTERED INIT HARDWARE\", \"<-\");\n        d.telemetry = telemetry;\n        d.robot = new RobotMap(hwMap);//, startPositionAndOrientation());\n//        d.robot.slamra.setPose(new Pose2d(0, 0,\n////                startPositionAndOrientation().StartPos.x/100,\n////                startPositionAndOrientation().StartPos.y/100,\n//\n//                new Rotation2d(0)));//Math.toRadians(startPositionAndOrientation().StartHeading))));\n//        d.robot.slamra.start();\n\n        mecanumDrive = new MecanumDrive(d);\n    }\n\n    public abstract Interfaces.MoveData.StartData startPositionAndOrientation();\n\n    public abstract void body() throws InterruptedException;\n\n    public void initMove() throws InterruptedException{\n\n    }\n\n    void exit(){//so we don't run into a wall at full speed\n        d.robot.bright.setPower(0);\n        d.robot.fright.setPower(0);\n        d.robot.bleft.setPower(0);\n        d.robot.fleft.setPower(0);\n//        d.robot.slamra.stop();\n\n    }\n\n\n\n    @Override\n    public void runOpMode() throws InterruptedException{\n\n        //INITIALIZATION\n        telemetry.addData(\"Initializing\", \"Started\");\n        telemetry.update();\n\n\n        d.isFinished = false;\n        d.isStarted = false;\n\n        d.driver = new CompleteController();\n        d.manip = new CompleteController();\n\n        d.driver.CompleteController(gamepad1);\n        d.manip.CompleteController(gamepad2);\n        //\n        //\n        //try {\n        initHardware(hardwareMap);\n        //} catch (Exception e){\n        //    StringWriter sw = new StringWriter();\n        //    PrintWriter pw = new PrintWriter(sw);\n        //    e.printStackTrace(pw);\n        //    telemetry.addData(sw.toString(), \"this\");\n        //}\n        //\n        //\n\n        //START POSITION\n        if (d.startData == null) {\n            d.startData = this.startPositionAndOrientation();\n            d.preWPos.set(d.startData.StartPos.clone());\n            d.wPos.set(d.startData.StartPos.clone());\n        }\n\n        final Interfaces.OtherCalc posDisplay = OtherCalcs.TelemetryPosition();\n        posDisplay.CalcOther(d);\n\n        telemetry.addData(\"Place robot here\", \"\\n\"+d.field);\n        telemetry.addData(\"heading\",\" \"+d.startData.StartNorthOffset +\" | position: (\"+String.valueOf(Math.round(d.startData.StartPos.x))+\", \"+String.valueOf(Math.round(d.startData.StartPos.y))+\")\");\n        telemetry.update();\n\n        initMove();\n\n        waitForStart();\n\n        d.isStarted = true;\n\n        //BODY\n        try {\n            body();\n        } catch (InterruptedException ie) {\n            telemetry.addData(\"Interrupted\",\"Exception\");\n            telemetry.update();\n        }\n        telemetry.addData(\"Body\", \"Finished\");\n        telemetry.update();\n\n        //EXIT\n        telemetry.addData(\"Exit\", \"Started\");\n        telemetry.update();\n        exit();\n        d.isFinished = true;\n        telemetry.addData(\"Exit\", \"Finished\");\n        telemetry.update();\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Op/ComplexOp.java	(revision 41983f78e90897951c2ad4db0f0ea7dce802dc80)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Op/ComplexOp.java	(date 1638221142000)
@@ -141,6 +141,8 @@
 //            telemetry.addData("barm ticks", d.robot.barm.getCurrentPosition()-d.initBarmPos);
 //            telemetry.addData("tarm ticks", d.robot.tarm.getCurrentPosition()-d.initTarmPos);
 //            telemetry.addData("sarm ticks", d.robot.sarm.getCurrentPosition()-d.initSarmPos);
+            telemetry.addData("cube pos", d.robot.cubeFindPipeline.cubePosPercent()[0] + ":" + d.robot.cubeFindPipeline.cubePosPercent()[1]);
+            telemetry.addData("cube area", d.robot.cubeFindPipeline.cubeSize());
             telemetry.addData("barm velocity", d.debugData1);
             telemetry.addData("tarm velocity", d.debugData2);
             telemetry.addData("barmAngle", d.barmAngle);
